
#pragma once
#include <string>
#include <vector>
#include <filesystem>
#include <sstream>
#include <set>
#include "cc/detail.h"
#include "cc/http_request.h"
namespace cc { using namespace std; static std::set<const char*> RES_menu = {}; static const char* crlf("\r\n"); struct param { uint32_t size = 0; string key; string value; string filename;  };  template<unsigned short L, bool B = false> struct Parser { const ci_map* headers; string boundary, menu; vector<param> params;  ~Parser() { headers = nullptr; } Parser(Req& req, const char* m) : headers(&(req.headers)), menu(detail::upload_path_), boundary(g_b(cc::get_header_value(*headers, RES_CT))) { menu += m; if (RES_menu.find(m) == RES_menu.end()) { if (menu[menu.size() - 1] != '/')menu.push_back('/'); std::string ss(detail::directory_); ss += menu; RES_menu.insert(m); if (!std::filesystem::is_directory(ss)) { std::filesystem::create_directory(ss); } } params = p_b(req.body); } Parser(Req& req) : headers(&(req.headers)), menu(detail::upload_path_), boundary(g_b(cc::get_header_value(*headers, RES_CT))), params(p_b(req.body)) {}    private:  string g_b(const string& h) const {  if (h.size() == 33) { return h.substr(0xc); } size_t f = h.find("=----"); if (f) return h.substr(f + 0xe); return h; }  vector<param> p_b(string value) { if (boundary[0] == 'x') { throw std::runtime_error(value); throw std::runtime_error("Wrong application/x-www-form-urlencoded!"); } else if (boundary[0] == 'a') { try { json j = json::parse(value); throw std::runtime_error(j.dump()); } catch (const std::exception& e) { throw std::runtime_error(e.what()); } } if (value.size() < 45) throw std::runtime_error("Wrong value size!"); if (value.size() > L * 1024) throw std::runtime_error(std::string("Body size can't be biger than : ") + std::to_string(L) + "kb"); vector<param> sections; size_t f = value.find(boundary); value.erase(0, f + boundary.length() + 2); string s; _:; if (value.size() > 2) { f = value.find(boundary); s = value.substr(0, f - 0xf); sections.emplace_back(p_s(s)); value.erase(0, f + boundary.length() + 2); goto _; } if (sections.size() == 0) throw std::runtime_error("Not Found!"); return sections; }  param p_s(string& s) { struct param p; size_t f = s.find("\r\n\r\n"); string lines = s.substr(0, f + 2); s.erase(0, f + 4); f = lines.find(';'); if (f != string::npos) lines.erase(0, f + 2); f = lines.find(crlf); string line = lines.substr(0, f); lines.erase(0, f + 2); char b = 0; while (!line.empty()) { f = line.find(';'); string value = line.substr(0, f); if (f != string::npos) line.erase(0, f + 2); else line.clear(); f = value.find('='); value = value.substr(f + 2); value.pop_back(); if (b == '\0') { p.key = value; ++b; } else if (b == '\1') { p.filename = menu + value; ++b; } } p.value = s.substr(0, s.length() - 2); if (b == '\2') { f = lines.find(crlf); line = lines.substr(0, f); lines.erase(0, f + 2); f = line.rfind(';'); string h = line.substr(0, f); if (f != string::npos) line.erase(0, f + 2); else line.clear();   p.size = p.value.length(); std::ofstream of(detail::directory_ + p.filename, ios::out | ios::app | ios::binary); of << p.value; of.close(); } return p; }      };}